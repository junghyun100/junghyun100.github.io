---
layout: post
title: "메모리 단편화와 내부 단편화, 외부 단편화 개념 및 차이점?"
tags: [OS]
comments: true
---
 
해당 Post는 내부 단편화, 외부 단편화 개념 및 차이점을 정리한 파일입니다.

---
## 메모리 단편화

 - RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태를 보고 메모리 단편화가 발생했다고 한다.


### 1. 내부 단편화

- 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비 되는 현상

<img src ="https://trello-attachments.s3.amazonaws.com/5e8aea3aaf239f64e5fe7306/820x393/d6b06e1de4afa891f98f931148041065/image.png" >

- 메모리를 할당하는 최소 블록 크기를 10K라고 가정합시다.<br> 만약 7K만큼의 공간을 사용하더라도 10K를 할당해야되고 <strong>나머지 3K를 낭비</strong>하게 됩니다.

### 2. 외부 단편화

- 메모리가 할당 및 해제 작업의 반복으로 작은 메모리가 중간중간에 존재
중간중간에 생긴 사용하지 않는 메모리가 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황
- 여유 공간이 여러 조각으로 나뉘는 현상

<img src ="https://trello-attachments.s3.amazonaws.com/5e8aea3aaf239f64e5fe7306/820x347/3113cb036860ef7b97257f0ca5cc9451/image.png">

- 프로세스 A,B,C 사이의 총 8K의 공간이 남아있습니다.<br> 프로세스  D는 7K의 공간을 필요로 하므로, 남은 공간은 충분합니다.<br>
그러나 분할하여 할당할 수 없으므로 <strong>프로세스D를 할당할 수 없는 문제가 발생</strong>합니다.

## 메모리 파편화 문제 해결 방법

### 1. 페이징(Paging)기법 - 가상메모리사용, 외부 단편화 해결, 내부 단편화 존재

보조기억장치를 이용한 가상메모리를 같은 크기의 블록으로 나눈 것을 페이지라고 하고 RAM을 페이지와 같은 크기로 나눈 것을 프레임이라고 할 때,

페이징 기법이란 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법.

페이지와 프레임을 대응시키기 위해 page mapping과정이 필요해서 paging table을 만든다.

페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제를 해결할 수 있다.

대신 페이지 단위에 알맞게 꽉채워 쓰는게 아니므로 내부 단편화 문제는 여전히 있다.

* 페이지 단위를 작게하면 내부 단편화 문제도 해결할 수 있겠지만 대신 page mapping 과정이 많아지므로 오히려 효율이 떨어질 수 있다. 

### 2. 세그멘테이션(Segmentation)기법 - 가상메모리사용, 내부 단편화 해결, 외부 단편화 존재

페이징기법에서 가상메모리를 같은 크기의 단위로 분할했지만 세그멘테이션기법에서는 가상메모리를 <br>서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환을 하게 된다.

각 세그먼트는 연속적인 공간에 저장되어 있다.

세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다.

마찬가지로 mapping을 위해 세그먼트 테이블이 필요하다.

(각 세그먼트 항목별 세그먼트 시작주소와 세그먼트의 길이 정보를 가지고 있음)

프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부단편화는 일어나지 않으나 <br>여전히 중간에 프로세스가 메모리를 해제하면 생기는 구멍, <br>즉 외부 단편화 문제는 여전히 존재한다.

### 3. 메모리 풀(Memory Pool)

필요한 메모리 공간을 필요한 크기, 개수 만큼 사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때마다 사용하고 반납하는 기법

메모리 풀 없이 동적할당과 해제를 반복하면 메모리의 랜덤한(실제로는 알고리즘에 의한) 위치에 할당과 해제가 반복되면서 <br>단편화를 일으킬 수 있겠지만 미리 공간을 할당해놓고 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 외부 단편화가 발생하지 않는다.

또한 필요한 크기만큼 할당을 해놓기 때문에 내부 단편화 또한 생기지 않는다.

하지만 메모리 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들었지만 쓰지 않았을 때 메모리 양이 커질 경우 사용하지 않아야 한다.

메모리의 할당, 해제가 잦은 경우에 메모리 풀을 쓰면 효과적이다.

미리 할당해놓고 사용하지 않는 순간에도 계속 할당해놓으므로 메모리 누수가 있는 방식이다.


---
