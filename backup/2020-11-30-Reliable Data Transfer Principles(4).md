---
layout: post
title: "네트워크 - Reliable Data Transfer Principles(4)"
tags: [컴퓨터 네트워크]
comments: true

---

컴퓨터 네트워크를 공부하면서 정리를 한 내용들 입니다.

-참고 K-mooc 부산 대학교 유영환 교수님 : 컴퓨터 네트워크 강의

---

Go-back-N을 조금 더 자세히 알아봅니다.

## Go-Back-N

<img src= "https://raw.githubusercontent.com/junghyun100/junghyun100.github.io/master/images/1130/Go-back_N.PNG">

시퀀스 넘버는 패킷의 헤더 부분에 들어가 동작을 합니다.

윈도우(window) 라는 것이 정의 되어 있습니다.

윈도우는 한 번에 보낼 수 있는, 

내가 ack를 받지 않아도, 한 번에 보낼 수 있는 

데이터 사이즈를 뜻합니다.

예를 들어 "large N으로 설정 되어 있다" 라고 가정을 합시다.

윈도우 사이즈가 N이라고 하면, N개의 패킷을 한꺼번에 보낼 수 있습니다. 

그림 상에서 `녹색`은 이미 전송을 해서 ack 까지 받아서 성공을 한 것입니다. 

`노란색`으로 되어 있는 부분은 연달아 데이터를 보낸 것입니다.

`파란색`으로 되어 있는 부분은 윈도우 사이즈가 N이고, 여유있는 공간입니다.

Ack가 도달하지 않아도 그 만큼 까지는 더 보낼 수 있다는 것입니다.

수신자 입장에서 데이터가 날아왔을 때 연속적으로, 

수신자 또한 데이터를 연속적으로 받습니다.

받았을 때 굳이 하나 하나의 패킷에 대해서 ack를 보내는 것이 아니라,

8개의 노란색으로 되어 있는 부분이 도착했다면, 

마지막 여덟 번 째에 대해서만도 ack를 보낼 수 있는 것입니다.

Go-back-N에서는 cumulative ACK를 쓰기 때문에,

이 마지막 패킷에 대해서 ACK가 왔다는 뜻은 앞의 7개도 제대로 도착 했다는 의미를 담고 있습니다.

Go-back-N에서의 타이머는 하나입니다. 

타이머 하나가 지금 내가 보냈으나 아직 ACK를 받지 못한 패킷 중에 

`가장 먼저 보낸 패킷에 대해`서 타이머가 설정이 되어 있습니다.

타이머 설정이 되어서 보낸 것들 중 가장 먼저의 데이터를 기다리다가 

ACK가 시간 안에 도착 하지 않는다면 해당 부분부터 다시 모두 재전송을 하게 됩니다.

그런데 ACK 꼭 끝에만 도달하는 것이 아니라, 

중간에 어떤 패킷의 ACK가 도달 할 수도 있습니다.

해당 번째까지의 패킷은 잘 도착했다는 의미가 되기에,

그렇게 되면 타이머를 옮겨서 해당 패킷 다음에 타이머를 설정 하고 기다리게 됩니다.

### 윈도우 사이즈

윈도우 사이즈는 사실 시간에 따라서 계속 변화 할 수 있습니다.

그래서 변화 한다는 의미라고 해서 `sliding window`라는 말을 사용합니다.

윈도우 사이즈가 크면 클 수록 `throughput`은 높아집니다.

한 번에 보낼 수 있는 패킷이 많아 지니까, 

`cumulative ACK`로 승인을 받을 수 있는 패킷도 많아 지는 것입니다.

그렇다고 해서 무조건 윈도우 사이즈가 크다고 좋은 것은 아닙니다.

왜냐하면 에러가 발생 했다는 판단이 들면 거기서 부터 다시 모두 재전송을 해야 됩니다.

80개의 사이즈를 가지는 상황에서 재전송하는 경우와 8개의 경우에서 재전송하는 경우를 생각해보면,

전체적인 시스템의 효율성으로 보면 재 전송 개수는 좀 줄이는 것이 좋습니다.

무조건 윈도우 사이즈를 크게 하면 재전송 해야 하는 패킷의 수가 기하급수적으로 늘어 날 수가 있기 때문에

전체적으로 시스템의 안정성을 헤칠 수가 있기 때문입니다.

윈도우 사이즈는 네트워크의 혼잡이나 receiver 버퍼가 수용 할 수 있는 크기를 넘어 서지 않는 한에서

최대한의 throughput을 낼 수 있는 크기로 하는 것이 적합하고,

그래서 시스템이 이런 값들을 고려 해서 동적으로 윈도우 크기를 조절하게 됩니다.

## Go-back-N Operation

<img src="https://raw.githubusercontent.com/junghyun100/junghyun100.github.io/master/images/1130/GBN%20operation.PNG">

Go-back-N을 가지고 패킷을 주고 받는 것을 살펴 봅시다. 

가정하기를 sender window 크기가 4로 한 번에 최대 4개의 패킷을 보낼 수 있습니다.

이런 경우에 go-back-N을 가지고 데이터를 주고 받는 모습을 살펴 보시면

일단 sender는 아까 stop-and-wait와 다르게 데이터가 준비 되었다고 하면 

0,1,2,3 네 개의 패킷을 한꺼번에 보낼 수가 있습니다.

그런데 이렇게 보내고 나면 receiver가 쭉 받게 됩니다. 

여기서 패킷 2가 loss가 되었다고 가정을 해 봅시다.

그러면 receiver는 패킷 0와 패킷 1은 제대로 받았기에 여기에 대해서 ACK를 보낼 수가 있습니다.

ACK 0, ACK 1 이렇게 보낼 수 있고 또는 여기 합쳐서 cumulative ACK로 하나만 날아 갈 수도 있습니다 경우에 따라서는.

이 사이에 시간이 벌어지면 나중에 시스템마다 차이는 있겠지만 

이 사이에 예를 들어 500 ms, 0.5초의 시간이 벌어지면

서로 다른 ACK가 날아 갈 수도 있는 것이고, 또 어떤 경우에는 연달아 도착하게 되면 하나의 ACK만 갈 수도 있는데

그래서 가정하기를 여기서는 ACK 0와 ACK 1이 따로 따로 왔다고 가정을 한 것입니다.

그런데 ACK를 0과 1을 하나씩 받았기 때문에 이제 4과 5번 패킷을 하나씩 보낼 수가 있게 되는 것입니다.

현재 전송 했으나 아직 ACK를 받지 않은 패킷의 수를 네 개 이하로 계속 유지 할 수가 있는 것입니다.

그런데 이 상황에서 보면 receiver가 패킷을 받아 봤더니 0, 1 다음에 2가 와야 하는데 3이 왔다면?

`in-order delivery`, 순서에 맞는 전송이 되어야 하는데 맞지 않은 겁니다.

그래서 일단 기본적인 go-back-N은 이런 경우에 그냥 순서에 맞지 않는 패킷이 오면 버려 버리게 되어 있습니다.

왜냐하면 나중에 어차피 재전송을 받을 것이기 때문에 버리게 되고 send ack 1을 다시 보냅니다.

어떤 타임아웃이 끝나기 전에 패킷 2에 대한 ack가 도달 해야 되는데 이 타임아웃이 끝날 때 까지

패킷 2에 대한 ack가 도달하지 않았기 때문에 패킷 2가 잘 도착하지 않았다,

문제가 발생 했다는 것을 sender가 알게 되고 패킷 2를 다시 재전송 하게 됩니다.

go-back-N이다 보니까 패킷 2부터 그 이후 3,4,5도는 이전에 전송했더라도,

패킷 2에서 문제가 있다는 것을 알았기 때문에 2번부터 그 뒤에 있는 것을 모조리 다시 보내게 됩니다.

## Selected Repeat

<img src="https://raw.githubusercontent.com/junghyun100/junghyun100.github.io/master/images/1130/selected%20repeat.PNG">

Selected Repeat 방식은 발생하면 그 패킷만 다시 재전송 하게 됩니다.

그리고 중간 중간에 개별적으로 ACK를 받기 때문에 꼭 순서대로 ACK를 받지 않아도 됩니다.

그림의 위 쪽이 sender이고 아래 쪽이 receiver인데 sender와 receiver 둘 다 똑같이 윈도우 사이즈는 N이라고 설정이 되어있고,

sender가 보냈으나 아직 ACK를 받지 못한 노란색 패킷과 이미 ACK를 받은 패킷이 있으면 초록색의 패킷이 중간 중간에 이렇게 들어 갈 수도 있습니다.

경우에 따라, receiver의 경우와 어떻게 비교 해 볼 수 있냐면

receiver는 앞의 이 빈칸은 이미 다 받아서 올린 상황입니다.

그림에서 sender는 노란색에 대해서는 ACK를 아직 받지 못 한 것으로 보이지만

receiver는 여기 해당 하는 것을 이미 받아서 뒤에 있는 이 부분 하고 합쳐서 조립을 해서 응용에 올려 준 것입니다.

ACK가 날아가는 중이거나 아니면 중간에 분실 되었거나 해서

아직 노란색으로 남아 있는 것이긴 하지만 어쨌든 receiver 입장에서는 받아서 응용에 올려 준 상황 입니다.

Receiver 입장에서 아직 받지 못한 것은 G로 표시된 부분 입니다. 

이 뒷 부분의 분홍색으로 되어 있는 부분은 이미 잘 받아서 ACK를 보낸 경우입니다. 

ACK를 보내서 위에는 초록색으로 되어 있습니다.

이 부분은 아직 응용 레벨에 올려 줄 수가 없는게 이 앞 부분이 아직 채워지지 않았기 때문입니다.

TCP는 `in-order delivery`고 순서가 다 맞게 맞추어 져야 보낼 수 있는 것인데

이 앞 부분이 아직 도달하지 않았기 때문에 이 부분은 아직 버퍼에 갖고 있는 것이고 기다리고 있는 상태입니다.

각각 `individual ACK`, 모든 패킷에 대해서 개별적인 ACK를 사용 한다는 것과

각각의 ACK를 받지 못한 패킷에 대해서 타이머가 개별적으로 설치 되어 있다 하는 것을 알아야 합니다.

## Selective Repeat Operation

<img src="https://raw.githubusercontent.com/junghyun100/junghyun100.github.io/master/images/1130/selected%20repeat%20operation.PNG">

Selective repeat이 동작하는 방식을 보시면 앞서 go-back-N과 마찬가지로 윈도우 사이즈는 4로 설정이 되어 있고

에러가 일어 나는 현상도 똑같은데 중간에 패킷 2가 없어진 상황입니다.

그러면 2번 패킷에 대한 타임 아웃이 걸릴 것이고요 걸리면 2번 패킷만 재 전송을 하게 됩니다.

재 전송 하고 뒤에 있는 3,4,5번은 재 전송 하지 않는 것이죠. 

오른쪽을 보시면 go-back-N에서는 2번이 도착 하지 않고 패킷 3이 도착 했을 때 그 패킷을 버렸습니다.

왜냐하면 뒤에 어차피 재전송을 받을 것이니까, 그런데 여기서는 보관을 해 둔다는 것입니다. 

그리고 3번에 대한 ACK를 별도로 보내게 됩니다.

TCP는 응용 레벨의 in-order delivery, 순서에 맞는 delivery를 해야 하는데

2번이 도달 하지 않은 상태에서 3,4,5번을 올릴 수 없기 때문에,

2번을 기다렸다가 2번이 도달 하고 나면 2번과 3번과 4번과 5번을 다 같이 합쳐서 보낼 수 있게 되겠습니다.

---
