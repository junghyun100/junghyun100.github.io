---
layout: post
title: "운영체제 - 병행제어(5)"
tags: [OS]
comments: true

---

OS를 공부하면서 정리를 한 내용들 입니다.<br>

세마포어 연산에서 생길 수 있는 문제인 데드락과 동기화와 관련된 전통적인 세 가지 문제에 대해 알아봅니다.

<a href="https://junghyun100.github.io/Semaphore&Mutex/">예전 포스팅 : 세마포어와 뮤텍스 차이점</a>

---

# Semaphores

일종의 추상 자료형.

세마포어 변수 S가 있을 때, 이것을 다루는 연산은 `P(S)`, `V(S)`가 있습니다.

`P(S)`는 공유 데이터를 획득하는 연산,

```
P(S): while(S<=0) do no-op;//대기
	S--;//획득
```

`V(S)`는 공유 데이터를 반납하는 연산입니다.

```
P(S):    
	S++;//반납
```

### Binanry semaphore(=mutex)

* 0 또는 1 값만 가질 수 있는 semaphore

	변수 S의 값이 1이라고 하면, 하나의 프로세스만 공유 데이터에 접근할 수 있는.

	일종의 LOCK을 거는 Mutual Exclusion문제를 푸는데 적용이 가능합니다.

### Counting semaphore

* 도메인이 0 이상인 임의의 정수 값

	자원의 갯수를 세는 의미로 세마포어 변수를 1보다 큰 정수값을 주면 여러개의 자원이 몇개가 남았는가?

	여분을 세는 역할을 하게 됩니다.

그런데 <strong>자원을 세는 것을 굳이 semaphore 변수로 하는 이유</strong>는 무언인가?

세마포어에서 P(S)와 V(S)에서 세마포어 변수 S-- 또는 S++가 원자적으로 수행된다고 가정을 합니다.

이런 가정 하에 프로그래머는 어떻게 세마포어를 사용해서 Synchronization을 할 것이냐를 다룹니다.

### 예를 들면

자원의 갯수가 5개가 있었는데, 1개만 남았다고 합시다.

프로세스 1개만 그것을 가져가야 하는데 세마포어 변수를 안쓴다면,

P연산을 해서 누군가가 하나 남은 것을 획득하는 도중에, CPU를 빼앗기고,

다른 쪽에서는 아직 변수가 줄어들지 않았다. 라고 생각하고 둘이 동시에 가져가는 등의 문제가 발생할 수 있습니다.

# DeadLock and Starvation

세마포어는 프로그래밍을 조금만 잘못해도 문제가 생길 수 있습니다.

예를 들면 어떤 작업을 하는데 있어서 세마포어 변수 S와 Q가 있는데,

이 작업은 변수 둘을 다 얻어야 할 수 있는 작업을 할 수 있다. 라고 가정을 해봅시다.

P0와 P1이 있는 상태에서
```
P(S);  P(Q); <- CPU를 뺏긴다.
P(Q);  P(S);
  .       . 
  .       .
  .       .
V(S);  V(Q);
V(Q);  V(S);

```

표시된 부분에서 P0이 S를 얻고 난 후 CPU를 뺏겨 P1에서 Q를 얻었습니다.

P1이 S를 획득하려 해도 P0이 가지고 있고, P0에 돌아가도 Q가 P1에 있으므로 영원히 아랫부가 실행이 안되는 문제가 발생합니다.

이런 문제가 발생하는 근본적인 이유는 자원을 내어놓는 것은 

일이 끝난 다음에야 자원을 내어놓고, 아닌 경우 자원을 내놓지 않는다는 점 입니다.

이것을 DeadLock이라고 합니다.

* 둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상

해당 예시는 각각의 프로세스에 대해서 Starvation이라고 할 수도 있습니다.

* idefinite blocking. 프로세스가 suspend된 이유에 해당하는 세마포어 큐에서 빠져나갈 수 없는 현상


여기서 문제를 해결하는 방법이 무엇이 있는가.

한 가지 방법은

```
P(S);  P(S);
P(Q);  P(Q);
  .       . 
  .       .
  .       .
V(S);  V(Q);
V(Q);  V(S);

```

획득 순서를 동일시 하는 것 입니다.

S를 얻고 Q를 얻어야 한다는 획득 순서를 가지게 된다면 S를 얻고 CPU를 빼앗긴다 하더라도

다른 프로세스에서는 이미 S가 어디선가 사용된다는 것을 알고 대기 상태가 되고 다시 CPU를 얻어왔을 때

작업을 진행할 수 있습니다. 이렇게 DeadLock은 해결할 수 있습니다.


-참고 KOCW 이화여자 대학교 반효경 교수님 : 운영체제 강의

---
