---
layout: post
title: "네트워크 - Peer to Peer Application"
tags: [컴퓨터 네트워크]
comments: true

---


컴퓨터 네트워크를 공부하면서 정리를 한 내용들 입니다.

-참고 K-mooc 부산 대학교 유영환 교수님 : 컴퓨터 네트워크 강의

---

## P2P Architecture

* 항상 켜져 있는 특정한 하나의 서버가 존재하지 않는다.

* 각각의 peer들, end systems들은 직접적으로 통신을 한다.

* peer들은 필요 할 때 접속 했다가, 주소도 항상 바뀔 수 있다.

> for example : 파일을 주고 받기 위한, 파일 공유를 위한 BitTorrent,
	        멀티미디어 데이터 스트리밍을 위한 KanKan,
	        Skype도 역시 P2P 방식으로 인터넷 전화, Voice of IP를 수행하고 있습니다.
		
<img src="https://raw.githubusercontent.com/junghyun100/junghyun100.github.io/master/images/1120/p2p.PNG">

그림의 P2P의 전체 구조를 보면 

클라이언트 서버 모델에서는 서버만 데이터를 업로드 하고 나머지는 다 데이터를 소비, 다운로드만 했었는데

P2P에서는 업로드도 하고 다운로드도 하는, 그래서 서버로도 동작하면서 클라이언트로도 동작하는 특징을 가지고 있습니다.

그래서 scalable 하다라고 말합니다.

<img src="https://raw.githubusercontent.com/junghyun100/junghyun100.github.io/master/images/1120/ClientServer%20VS%20P2P.PNG">

새로운 peer가 들어오면 물론 데이터를 데이터를 요구하기도 하지만 서버로도 동작하기 때문에 

클라이언트 수가 늘어나면 서버가 감당해야하는 부분이 이렇게 선형적으로 증가 합니다.

그런데 P2P에서는 클라이언트들이 일정부분 담당을 해 주기 때문에 

물론 처음 접속해서 자기가 공유 할 데이터가 없을 경우에는 서버의 역할은 못하겠지만 

처음 접속해서 데이터를 다운 받고 나면 그 다음부터는 다운 받은 데이터를 

다른 사람한테 제공 해 줄 수 있기 때문에 오버헤드가 많이 증가하지 않고 천천히 증가하는 특징이 있습니다.

## Case Study : bitTorrent

<img src="https://raw.githubusercontent.com/junghyun100/junghyun100.github.io/master/images/1120/BitTorrent.PNG">

일단 P2P를 통해서 파일 공유를 할 때에는 파일이 크게 한 덩어리로 되어있지 않습니다. 

파일은 다 작은 덩어리로 나누어져 있습니다.

BitTorrent 같은 경우에는 하나의 chunk라고 불리는 데이터 단위가 있는데 

약 256 kb 정도의 크기를 가집니다.

이렇게 나누어져 있는 이유는 아주 큰 덩어리를 하나의 peer한테 바로 받으려면

그 보내주는 peer가 계속 내가 다운 받을 동안 접속 해 있어야 합니다. 

chunk를 잘게 나누어 놓아야 일부는 A라는 사람에게 받고, 일부는 B라는 사람에게 받는 식으로 해서

조합하여 하나의 덩어리를 만들 수 있는 것이기 때문에 파일을 큰 덩어리로 하지 않고 잘게 나누어 놓았습니다.

> torrent : 파일 chunk를 주고 받는 peer들의 그룹

bittorrent에서 실제 데이터들은 peer들이 서로 주고 받지만 특별한 서버가 있습니다.

### Tracker

어떤 특정한 사용자가 Bittorrent에 접속을 했을 때 누구와 연결을 수립 해야 할 지 알지 못합니다.

처음에는 상대 peer들의 IP주소를 모르는 것이기 때문에 처음 접속한 사람은 Tracker라는 서버에 접속 해야 합니다.

접속 해서 어떠한 데이터가 필요하고, 누구한테 접속해야 하는지 등의 정보를 Tracker가 가지고 있습니다.

## BitTorrent : Receving and Sending Chunks

Chunk를 받을 때 보면 하나의 전체 파일을 한 peer에서 받지 않습니다.

그렇게 되려면 시간도 오래 걸리고, 다운 받을 동안 나한테 데이터를 보내주고 있는 peer가 

계속 접속하고 있을 것이라는 보장도 없기 때문입니다.

그래서 주기적으로 Alice는 전체 파일의 chunk를 쭉 나누어서 특정 chunk를 누가 갖고 있는지를 조사 합니다.

예를 들어서 첫 번째 chunk는 5개의 node가 가지고 있고, 

두 번째 chunk는 2개의 node가 가지고 있고, 

세 번째 chunk는 10개의 peer가 가지고 있다.

그러면 Alice 입장에서는 2개의 peer만이 가지고 있는 chunk를 미리 받아 놓아야 유리 합니다.

### why?
 
2개의 peer가 접속을 끊고 나가 버리면 누구한테 받을 것인지 기약이 없기 때문입니다.

Alice는 만약 여러 개의 chunk를 받을 수 있다면 `rarest first`, 

가장 적은 수의 peer가 가지고 있는 chunk를 먼저 받는 것이 

데이터를 다운받는데 더 유리합니다.

그러나 P2P에서 문제가 되는 것이 Free-rider라는 것인데,

free-rider라는 것은 공짜로 이용하는 이라는 뜻 입니다.

각 peer들 한테 당신이 다운로드 받을 수 있는 

데이터의 전송속도를 정하고, 업로드 하는 전송 속도를 정하라고 한다면

많은 사람들이 다운로드만 받고 싶지 자원을 써 가면서 남한테 데이터를 제공하려 하지 않을 겁니다.

자신의 이익만 취하고 서비스는 하지 않으려는 것 입니다.

많은 사람들이 실제로 P2P가 처음 서비스 되었을 때 이러한 행동을 취함으로써 

실제적으로 네트워크가 제대로 동작하지 않는 그런 문제가 있었습니다.

이런 Free-rider 문제를 해결하기 위해서 많은 연구가 있었는데 

Bittorrent는 tit-for-tat이라는 방식을 쓰게 됩니다.

### tit-for-tat

"결국 받은 대로 갚아 주다" 라는 뜻이라고 생각하시면 됩니다.

각각의 peer들은 주기적으로 자기한테 가장 데이터를 잘 주는 4개의 top 4 peer를 선정합니다.

매 10초 마다 이것을 선정 해서 top 4 peer 한테는 서비스를 잘 해주는 것 입니다.

이렇게만 하면 나에게 잘 해주는 4개의 peer한테만 서비스를 잘 해주니까 

상대 peer 입장에서도 내가 top 4에 해당되어 있겠죠.

결국은 이 두 peer만 서로 데이터를 계속 주고 받을 수 있게 되는 것입니다.

이런 경우 어떤 사용자가 처음 Bittorrent에 접속 했을 때, 

이 사람은 처음 접속 했기 때문에 누구한테 데이터를 제공 해 준 적이 없습니다.

그러면 결국 이 사람은 top 4에 들어가지 못하므로 데이터를 받지 못하게 됩니다.

신규 참여자가 top 4에 들어갈 수 있는 가능성이 없기 때문에

그것을 방지하기 위해서 top 4를 측정 하면서 

매 30초마다 랜덤하게 하나의 peer를 선정해서 서비스를 제공 합니다.

---
